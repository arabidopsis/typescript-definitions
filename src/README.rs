/*!


<div style="float:right; padding-left:2em;">
<img
src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjE5IDE5IDEz
NC4wNzIgMTk3LjE1OSIgaGVpZ2h0PSIyNjcuODM4IiB3aWR0aD0iMTgyLjEzNiI+PHBhdGggZD0i
TTE5IDE0OS4xMjN2NjcuMDM2aDEzNC4wNzJWODIuMDg3SDE5em0xMDguMDQ1LTUuMzQyYzMuNDA1
Ljg1MSA2LjAwMSAyLjM2MiA4LjM4NSA0LjgzMSAxLjIzNCAxLjMyIDMuMDY0IDMuNzI0IDMuMjEz
IDQuMjk5LjA0My4xNy01Ljc4OCA0LjA4Ni05LjMyIDYuMjc4LS4xMjkuMDg1LS42NC0uNDY4LTEu
MjE0LTEuMzItMS43MjQtMi41MS0zLjUzMy0zLjU5Ni02LjMtMy43ODgtNC4wNjQtLjI3Ni02LjY4
MiAxLjg1Mi02LjY2IDUuNDA2IDAgMS4wNDIuMTQ5IDEuNjYuNTc0IDIuNTEuODk0IDEuODUyIDIu
NTU0IDIuOTU5IDcuNzY4IDUuMjE1IDkuNTk4IDQuMTI4IDEzLjcwNSA2Ljg1MiAxNi4yNTkgMTAu
NzI2IDIuODUyIDQuMzIgMy40OSAxMS4yMTUgMS41NTMgMTYuMzQ0LTIuMTI4IDUuNTc1LTcuNDA1
IDkuMzYzLTE0LjgzMyAxMC42MTktMi4yOTguNDA0LTcuNzQ2LjM0LTEwLjIxNS0uMTA2LTUuMzg0
LS45NTgtMTAuNDkxLTMuNjE4LTEzLjY0LTcuMTA4LTEuMjM1LTEuMzYyLTMuNjQtNC45MTYtMy40
OTEtNS4xNzIuMDY0LS4wODUuNjE3LS40MjUgMS4yMzQtLjc4Ny41OTYtLjM0IDIuODUyLTEuNjM5
IDQuOTgtMi44NzNsMy44NTItMi4yMzUuODA5IDEuMTkyYzEuMTI4IDEuNzI0IDMuNTk2IDQuMDg2
IDUuMDg2IDQuODczIDQuMjc3IDIuMjU2IDEwLjE1MSAxLjkzNyAxMy4wNDUtLjY2IDEuMjM1LTEu
MTI3IDEuNzQ1LTIuMjk4IDEuNzQ1LTQuMDIxIDAtMS41NTQtLjE5MS0yLjIzNS0xLTMuNDA1LTEu
MDQzLTEuNDktMy4xNy0yLjc0Ni05LjIxNS01LjM2My02LjkxNi0yLjk4LTkuODk1LTQuODMxLTEy
LjYyLTcuNzY4LTEuNTc0LTEuNzAyLTMuMDY0LTQuNDI2LTMuNjgxLTYuNzA0LS41MS0xLjg5NC0u
NjM4LTYuNjQtLjIzNC04LjU1NSAxLjQyNi02LjY4MiA2LjQ3LTExLjM0MyAxMy43NDgtMTIuNzI2
IDIuMzYyLS40NDcgNy44NTItLjI3NiAxMC4xNzIuMjk4em0tMzEuNDc1IDUuNTk3bC4wNDMgNS40
OUg3OC4xNjJ2NDkuNTg2SDY1LjgxOXYtNDkuNTg1SDQ4LjM2OHYtNS4zODVjMC0yLjk3OS4wNjQt
NS40NjkuMTUtNS41MzMuMDYzLS4wODUgMTAuNjgyLS4xMjcgMjMuNTU3LS4xMDZsMjMuNDMxLjA2
NHoiIGZpbGw9IiMwMDdhY2MiLz48cGF0aCBkPSJNMTQ3LjE2IDgwLjI4NGwtNS4xNDctMy4xODdh
NzAuNDA0IDcwLjQwNCAwIDAgMC0uMTQ3LTEuNWw0LjQyNC00LjEyNWMuNDUtLjQyLjY1Mi0xLjA0
LjUzLTEuNjQyYTEuNzY1IDEuNzY1IDAgMCAwLTEuMTE3LTEuMzE1bC01LjY1NS0yLjExNGE2My4y
NSA2My4yNSAwIDAgMC0uNDQzLTEuNDZsMy41MjgtNC45YTEuNzcyIDEuNzcyIDAgMCAwLTEuMTUz
LTIuNzg1bC01Ljk2NC0uOTdhNTAuMTk1IDUwLjE5NSAwIDAgMC0uNzE3LTEuMzRsMi41MDYtNS41
YTEuNzY0IDEuNzY0IDAgMCAwLS4xMzgtMS43MiAxLjc2NCAxLjc2NCAwIDAgMC0xLjUzNS0uNzg3
bC02LjA1My4yMTFhNDguMjIxIDQ4LjIyMSAwIDAgMC0uOTU2LTEuMTZsMS4zOS01Ljg5NWExLjc3
MSAxLjc3MSAwIDAgMC0yLjEzMS0yLjEzMmwtNS44OTQgMS4zOWE1MC45MiA1MC45MiAwIDAgMC0x
LjE2Mi0uOTU3bC4yMTItNi4wNTNhMS43NjUgMS43NjUgMCAwIDAtLjc4Ni0xLjUzNSAxLjc3IDEu
NzcgMCAwIDAtMS43Mi0uMTRsLTUuNSAyLjUwOGMtLjQ0My0uMjQ0LS44OS0uNDg1LTEuMzM4LS43
MThsLS45NzMtNS45NjVhMS43NzIgMS43NzIgMCAwIDAtMi43ODMtMS4xNTNsLTQuOTA0IDMuNTI4
YTUzLjc2NSA1My43NjUgMCAwIDAtMS40NTctLjQ0MmwtMi4xMTUtNS42NTdhMS43NjcgMS43Njcg
MCAwIDAtMS4zMTUtMS4xMTggMS43NzYgMS43NzYgMCAwIDAtMS42NC41M2wtNC4xMjcgNC40Mjdh
NTMuMjMgNTMuMjMgMCAwIDAtMS41LS4xNDdsLTMuMTg2LTUuMTVhMS43NzEgMS43NzEgMCAwIDAt
My4wMTMgMGwtMy4xODYgNS4xNWMtLjUwMi4wNDEtMS4wMDMuMDkyLTEuNTAxLjE0N2wtNC4xMjgt
NC40MjhhMS43NyAxLjc3IDAgMCAwLTIuOTU1LjU5bC0yLjExNSA1LjY1NmMtLjQ5LjE0LS45NzUu
MjktMS40NTguNDQybC00LjkwMy0zLjUyOGExLjc3NSAxLjc3NSAwIDAgMC0yLjc4NSAxLjE1M2wt
Ljk3MiA1Ljk2NWMtLjQ1LjIzMy0uODk1LjQ3My0xLjM0LjcxOGwtNS41LTIuNTA3YTEuNzY1IDEu
NzY1IDAgMCAwLTEuNzE4LjE0Yy0uNTEuMzQtLjgxLjkyMS0uNzg2IDEuNTM0bC4yMSA2LjA1M2Mt
LjM5LjMxMy0uNzc4LjYzMi0xLjE2MS45NTZsLTUuODk1LTEuMzlhMS43NzcgMS43NzcgMCAwIDAt
MS42Ni40NzIgMS43NyAxLjc3IDAgMCAwLS40NzIgMS42NmwxLjM4OCA1Ljg5NmMtLjMyMi4zODIt
LjY0MS43Ny0uOTU0IDEuMTZsLTYuMDUzLS4yMWExLjc3IDEuNzcgMCAwIDAtMS42NzQgMi41MDZs
Mi41MDcgNS41YTU2LjkxIDU2LjkxIDAgMCAwLS43MTggMS4zNGwtNS45NjMuOTdhMS43NzIgMS43
NzIgMCAwIDAtMS4xNTMgMi43ODVsMy41MjcgNC45YTU0LjcgNTQuNyAwIDAgMC0uNDQyIDEuNDZs
LTUuNjU3IDIuMTE0YTEuNzczIDEuNzczIDAgMCAwLS41ODcgMi45NTZsNC40MjUgNC4xMjdjLS4w
NTUuNDk4LS4xMDQgMS0uMTQ2IDEuNWwtNS4xNSAzLjE4N2ExLjc3IDEuNzcgMCAwIDAgMCAzLjAx
Mmw1LjE1IDMuMTg3Yy4wNDIuNTAxLjA5IDEuMDAyLjE0NiAxLjVsLTQuNDI1IDQuMTI3YTEuNzcx
IDEuNzcxIDAgMCAwIC41ODcgMi45NTVsNS42NTcgMi4xMTVjLjE0LjQ5LjI4OS45NzYuNDQyIDEu
NDZsLTMuNTI3IDQuOTAxYTEuNzcgMS43NyAwIDAgMCAxLjE1NCAyLjc4NGw1Ljk2Mi45N2MuMjMz
LjQ1Mi40NzIuODk4LjcxOCAxLjM0MmwtMi41MDcgNS40OThhMS43NjggMS43NjggMCAwIDAgLjE0
IDEuNzJjLjM0Mi41MTIuOTI0LjgxIDEuNTM0Ljc4Nmw2LjA1LS4yMTJjLjMxNi4zOTQuNjM0Ljc4
Ljk1NyAxLjE2M2wtMS4zODggNS44OTZhMS43NjMgMS43NjMgMCAwIDAgLjQ3MiAxLjY1NyAxLjc2
NCAxLjc2NCAwIDAgMCAxLjY2LjQ3MWw1Ljg5NS0xLjM4OGMuMzgzLjMyNS43Ny42NDIgMS4xNjIu
OTU0bC0uMjExIDYuMDUzYTEuNzcgMS43NyAwIDAgMCAyLjUwNSAxLjY3NGw1LjUtMi41MDdjLjQ0
My4yNDYuODg4LjQ4NSAxLjMzOS43MmwuOTcyIDUuOTZhMS43NzUgMS43NzUgMCAwIDAgMi43ODUg
MS4xNTVsNC45LTMuNTNjLjQ4NC4xNTQuOTcuMzA0IDEuNDYuNDQ0bDIuMTE1IDUuNjU1Yy4yMTQu
NTc0LjcxIDEgMS4zMTQgMS4xMTZhMS43NjIgMS43NjIgMCAwIDAgMS42NC0uNTNsNC4xMjktNC40
MjVjLjQ5Ny4wNTguOTk5LjEwNiAxLjUuMTVsMy4xODcgNS4xNDhhMS43NzMgMS43NzMgMCAwIDAg
My4wMTMgMGwzLjE4Ny01LjE0OGE1Ny41NjIgNTcuNTYyIDAgMCAwIDEuNS0uMTVsNC4xMjYgNC40
MjVjLjQxOC40NSAxLjA0LjY1MiAxLjY0LjUzYTEuNzY3IDEuNzY3IDAgMCAwIDEuMzE1LTEuMTE2
bDIuMTE1LTUuNjU1Yy40OS0uMTQuOTc2LS4yOSAxLjQ2LS40NDRsNC45IDMuNTNhMS43NzMgMS43
NzMgMCAwIDAgMi43ODQtMS4xNTVsLjk3My01Ljk2Yy40NS0uMjM1Ljg5NS0uNDc3IDEuMzM5LS43
Mmw1LjUgMi41MDdhMS43NjggMS43NjggMCAwIDAgMi41MDUtMS42NzRsLS4yMTEtNi4wNTNhNDgu
MTQgNDguMTQgMCAwIDAgMS4xNi0uOTU0bDUuODk2IDEuMzg4YTEuNzYyIDEuNzYyIDAgMCAwIDEu
NjU5LS40NyAxLjc3IDEuNzcgMCAwIDAgLjQ3Mi0xLjY1OGwtMS4zOS01Ljg5NmMuMzI1LS4zODQu
NjQzLS43Ny45NTUtMS4xNjNsNi4wNTMuMjEyYTEuNzYzIDEuNzYzIDAgMCAwIDEuNTM1LS43ODZj
LjM0Mi0uNTEuMzk1LTEuMTYuMTM4LTEuNzJsLTIuNTA2LTUuNDk4Yy4yNDUtLjQ0NC40ODUtLjg5
LjcxNy0xLjM0Mmw1Ljk2NC0uOTdhMS43NyAxLjc3IDAgMCAwIDEuMTUzLTIuNzg0bC0zLjUyOC00
LjljLjE1Mi0uNDg1LjMtLjk3LjQ0My0xLjQ2bDUuNjU1LTIuMTE2Yy41NzUtLjIxNSAxLS43MSAx
LjExNy0xLjMxNGExLjc2MSAxLjc2MSAwIDAgMC0uNTMtMS42NGwtNC40MjQtNC4xMjhjLjA1NC0u
NDk4LjEwMy0xIC4xNDYtMS41bDUuMTQ5LTMuMTg3YTEuNzcgMS43NyAwIDAgMCAwLTMuMDEyem0t
MzQuNDU2IDQyLjcwOGEzLjY0OSAzLjY0OSAwIDAgMS0yLjc5NS00LjMzNCAzLjYzNyAzLjYzNyAw
IDAgMSA0LjMyMi0yLjggMy42NDYgMy42NDYgMCAwIDEgMi43OTcgNC4zMzEgMy42NDYgMy42NDYg
MCAwIDEtNC4zMjQgMi44MDN6bS0xLjc1LTExLjgzMmEzLjMyIDMuMzIgMCAwIDAtMy45NDIgMi41
NTVsLTEuODI4IDguNTNhNDQuNjQ1IDQ0LjY0NSAwIDAgMS0xOC41IDMuOTgyIDQ0LjY4OCA0NC42
ODggMCAwIDEtMTguODktNC4xNjJsLTEuODI1LTguNTNhMy4zMTkgMy4zMTkgMCAwIDAtMy45NDIt
Mi41NTNsLTcuNTMgMS42MTdhNDQuNjc4IDQ0LjY3OCAwIDAgMS0zLjg5My00LjU5aDM2LjY0Yy40
MTQgMCAuNjktLjA3NC42OS0uNDUydi0xMi45NmMwLS4zNzgtLjI3Ni0uNDUzLS42OS0uNDUzSDc2
LjUyOFY4NS45M2gxMS41OWMxLjA1OCAwIDUuNjU2LjMwMiA3LjEyNyA2LjE4LjQ2IDEuODA4IDEu
NDcgNy42OSAyLjE2MyA5LjU3MS42ODkgMi4xMTIgMy40OTQgNi4zMyA2LjQ4MiA2LjMzaDE4LjI1
OGMuMjA4IDAgLjQzLS4wMjQuNjYyLS4wNjZhNDQuOTg4IDQ0Ljk4OCAwIDAgMS00LjE1MiA0Ljg3
MnptLTUwLjY3NiAxMS42NTRhMy42NCAzLjY0IDAgMCAxLTQuMzI1LTIuOCAzLjY1IDMuNjUgMCAw
IDEgMi43OTYtNC4zMzMgMy42NDggMy42NDggMCAwIDEgMS41MjkgNy4xMzN6bS0xMy45LTU2LjM2
M2EzLjY0OCAzLjY0OCAwIDAgMS0xLjg1MiA0LjgxMiAzLjYzOSAzLjYzOSAwIDAgMS00LjgwNS0x
Ljg1NiAzLjY0OCAzLjY0OCAwIDAgMSAxLjg1My00LjgxMiAzLjY0IDMuNjQgMCAwIDEgNC44MDUg
MS44NTZ6bS00LjI3IDEwLjEyN2w3Ljg0NC0zLjQ4NmEzLjMyNiAzLjMyNiAwIDAgMCAxLjY4OC00
LjM4N2wtMS42MTUtMy42NTNoNi4zNTR2MjguNjRINDMuNTU4YTQ0Ljg4NCA0NC44ODQgMCAwIDEt
MS43MDgtMTIuMjk4YzAtMS42MjcuMDg4LTMuMjM2LjI1Ny00LjgxNnptMzQuNDIzLTIuNzgydi04
LjQ0aDE1LjEzYy43ODIgMCA1LjUyLjkwMiA1LjUyIDQuNDQ0IDAgMi45NC0zLjYzNCAzLjk5NS02
LjYyMiAzLjk5NWgtMTQuMDN6bTU0Ljk4OCA3LjU5OGE0NC44IDQ0LjggMCAwIDEtLjEyMyAzLjMz
aC00LjZjLS40NiAwLS42NDUuMzAxLS42NDUuNzUzdjIuMTEyYzAgNC45NzItMi44MDQgNi4wNTQt
NS4yNjEgNi4zMy0yLjM0LjI2My00LjkzNC0uOTgtNS4yNTQtMi40MTItMS4zOC03Ljc2My0zLjY4
LTkuNDItNy4zMTItMTIuMjg2IDQuNTA3LTIuODYyIDkuMTk3LTcuMDg1IDkuMTk3LTEyLjczNyAw
LTYuMTAzLTQuMTg0LTkuOTQ3LTcuMDM1LTExLjgzMy00LjAwMi0yLjYzNy04LjQzMi0zLjE2NS05
LjYyNy0zLjE2NUg1My4yODZjNi40NS03LjIgMTUuMTk0LTEyLjMgMjUuMDgyLTE0LjE1Nmw1LjYw
OCA1Ljg4M2EzLjMxNiAzLjMxNiAwIDAgMCA0LjY5NC4xMDdsNi4yNzQtNmMxMy4xNDcgMi40NDcg
MjQuMjc4IDEwLjYzIDMwLjY5MiAyMS44NmwtNC4yOTUgOS43YTMuMzMgMy4zMyAwIDAgMCAxLjY5
IDQuMzg3bDguMjcgMy42NzNjLjE0MiAxLjQ2OC4yMTcgMi45NTEuMjE3IDQuNDU0ek04My45Nzgg
MzIuMzI2YTMuNjM4IDMuNjM4IDAgMCAxIDUuMTQ4LjExOCAzLjY1IDMuNjUgMCAwIDEtLjEyIDUu
MTU2IDMuNjM2IDMuNjM2IDAgMCAxLTUuMTQ4LS4xMiAzLjY1IDMuNjUgMCAwIDEgLjEyLTUuMTU0
em00Mi42MjUgMzQuMzAyYTMuNjM4IDMuNjM4IDAgMCAxIDQuODA0LTEuODU1IDMuNjQ5IDMuNjQ5
IDAgMCAxIDEuODUyIDQuODEyIDMuNjM4IDMuNjM4IDAgMCAxLTQuODA1IDEuODU2IDMuNjUyIDMu
NjUyIDAgMCAxLTEuODUxLTQuODEzeiIvPjwvc3ZnPgo=
">
</div>

# typescript-definitions

> **Exports serde-serializable structs and enums to Typescript definitions.**

[![](https://img.shields.io/crates/v/typescript-definitions.svg)](https://crates.io/crates/typescript-definitions)
[![](https://docs.rs/typescript-definitions/badge.svg)](https://docs.rs/typescript-definitions)
![License](https://img.shields.io/crates/l/typescript-definitions.svg)


**Good news everyone!** Version 0.1.9 introduces a feature gated option to
generate typescript [type guards](https://www.typescriptlang.org/docs/handbook/advanced-types.html). Now you can:

```typescript
    import {Record, isRecord} from "./mytypescript";
    const a: any = JSON.parse(some_string_from_your_server)
    if (isRecord(a)) {
        // all the typescript type checking goodness plus a bit of safety
    } else {
        // something went wrong.
    }
```

See [Type Guards](#type-guards) below.

---


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [typescript-definitions](#typescript-definitions)
	* [Motivation ðŸ¦€](#motivation)
	* [Using `typescript-definitions`](#using-typescript-definitions)
		* [Getting the toolchains](#getting-the-toolchains)
	* [Using `type_script_ify`](#using-type_script_ify)
	* [Features](#features)
	* [Serde attributes.](#serde-attributes)
	* [typescript-definition attributes](#typescript-definition-attributes)
	* [Type Guards](#type-guards)
		* [Limitations of JSON](#limitations-of-json)
		* [Limitations of Generics](#limitations-of-generics)
	* [Examples](#examples)
	* [Problems](#problems)
	* [TODO](#todo)
	* [Credits](#credits)
	* [License](#license)

<!-- /code_chunk_output -->

---


## Motivation ðŸ¦€

Now that rust 2018 has landed
there is no question that people should be using rust to write server applications (what are you thinking!).
But generating wasm from rust code to run in the browser is currently much too bleeding edge.

Since javascript will be dominant on the client for the forseeable future there remains the
problem of communicating with your javascript from your rust server.

Fundamental to this is to keep the datatypes on either side of the connection (http/websocket) in sync.

Typescript is an incremental typing system for javascript that is as almost(!) as tricked as rust... so
why not create a typescript definition library based on your rust code?

Please see [Credits](#credits).

`typescript-definitions` (as of 0.1.7) uses `edition=2018` (heh).

example:

```rust
// #[cfg(target_arch="wasm32")]
use wasm_bindgen::prelude::*;

use serde::Serialize;
use typescript_definitions::TypescriptDefinition;

#[derive(Serialize, TypescriptDefinition)]
#[serde(tag = "tag", content = "fields")]
enum Enum {
    V1 {
        #[serde(rename = "Foo")]
        foo: bool,
    },
    V2 {
        #[serde(rename = "Bar")]
        bar: i64,
        #[serde(rename = "Baz")]
        baz: u64,
    },
    V3 {
        #[serde(rename = "Quux")]
        quux: String,
    },
    #[serde(skip)]
    Internal {
        err: String
    },
}
```

Using [wasm-bindgen](https://rustwasm.github.io/wasm-bindgen/) this will output in your `*.d.ts` definition file:

```typescript
export type Enum =
    | {tag: "V1", fields: { Foo: boolean } }
    | {tag: "V2", fields: { Bar: number, Baz: number } }
    | {tag: "V3", fields: { Quux: string } }
    ;
```

## Using `typescript-definitions`

**NB**: Please note that these macros - by default - work *only for the debug build* since they pollute the
code with strings and methods all of which are proabably not useful in any release (Since
you are only using them to extract information about your current types from your *code*). In
release builds they become no-ops. This means that there is *no cost* to your release exes/libs
or to your users by using these macros. Zero cost abstraction indeed. Beautiful.

Also, although you might need nightly to run `wasm-bingen` *your* code can remain stable.

See [features](#features) below if you really want them in your release build.

There is a very small example in the repository that
[works for me (TM)](https://bitbucket.org/athaliana/typescript-definitions/src/master/example/) if you want to get started
on your own.

This crate only exports two derive macros: `TypescriptDefinition` and `TypeScriptify`, a simple
trait `TypeScriptifyTrait` and a (very simple) serializer for byte arrays.

In your crate create a lib target in `Cargo.toml` pointing
to your "interfaces"

```toml
[lib]
name = "mywasm" # whatever... you decide
path = "src/interface.rs"
crate-type = ["cdylib"]


[dependencies]
typescript-definitions = "0.1"
serde = { version = "1.0", features = ["derive"] }

[target.wasm32-unknown-unknown.dependencies]
wasm-bindgen = "0.2"

```

Then you can run (see [here](#using-type_script_ify) if you don't want to go near WASM):

```sh
$ cargo +nightly build --target wasm32-unknown-unknown
$ mkdir pkg
$ wasm-bindgen target/wasm32-unknown-unknown/debug/mywasm.wasm --typescript --out-dir pkg/
$ cat pkg/mywasm.d.ts # here are your definitions
```

What just happened? [This.](https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/typescript_custom_section.html)

### Getting the toolchains

If you don't have these tools then [see here](https://rustwasm.github.io/wasm-bindgen/whirlwind-tour/basic-usage.html)
(You might also need to get [rustup](https://rustup.rs) first):

```sh
$ rustup target add wasm32-unknown-unknown --toolchain nightly
$ cargo +nightly install wasm-bindgen-cli
```

or use wasm-pack (the typescript library will be in `pkg/mywasm.d.ts`).

```sh
$ curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
$ wasm-pack build --dev
$ cat pkg/mywasm.d.ts
```

## Using `type_script_ify`

You can ignore WASM *totally* by deriving using `TypeScriptify`:

```rust
// interface.rs

// wasm_bindgen not needed
// use wasm_bindgen::prelude::*;
use serde::Serialize;
use typescript_definitions::TypeScriptify;

#[derive(Serialize, TypeScriptify)]
pub struct MyStruct {
    v : i32,
}

 // Then in `main.rs` (say) you can generate your own typescript
 // specification using `MyStruct::type_script_ify()`:


// main.rs

// need to pull in trait
use typescript_definitions::TypeScriptifyTrait;

fn main() {
    if cfg!(any(debug_assertions, feature="export-typescript")) {

        println!("{}", MyStruct::type_script_ify());
    };
    // prints "export type MyStruct = { v: number };"
}
```
Use the cfg macro To protect any use of `type_script_ify()` if you need to.

If you have a generic struct such as:

```rust
use serde::Serialize;
use typescript_definitions::TypeScriptify;
#[derive(Serialize, TypeScriptify)]
pub struct Value<T> {
    value: T
}
```

then you need to choose a concrete type to generate the typescript: `Value<i32>::type_script_ify()`. The concrete type
doesn't matter as long as it obeys rust restrictions; the output will still be generic `export type Value<T> { value: T }`.

Currently type bounds are discarded in the typescript.

So basically with `TypeScriptify` *you* have to create some binary that, via `println!` or similar statements, will
cough up a typescript library file. I guess you have more control here... at the expense of complicating
your `Cargo.toml` file and your code.


## Features

As we said before `typescript-descriptions` macros pollute your code with
static strings and other garbage. Hence, by default, they only *work* in debug mode.


If you actually want `T::type_script_ify()` (for TypeScriptify) available in your
release code then change your `Cargo.toml` file to:

```toml
[dependencies.typescript-definitions]
version = "0.1"
features = ["export-typescript"]

## OR

typescript-definitions = { version="0.1",  features=["export-typescript"]  }
```

AFAIK the strings generated by TypescriptDescription don't survive the invocation
of `wasm-bindgen` even in debug mode. So your *.wasm files are clean. You still need
to add `--features=export-typescript` to generate anything in release mode though.


## Serde attributes.

See Serde [Docs](https://serde.rs/enum-representations.html#internally-tagged).

`typescript-definitions` tries to adhere to the meaning of serde attributes
like`#[serde(tag="type")]` and `#[serde(tag="tag", content="fields")]`.

Before 0.1.8 we had an implicit default tag of "kind" for enums. Now we don't
(although we still have a implicit `transparent` on NewTypes).


Serde attributes understood

* rename, rename_all:
* tag:
* content:
* skip: (`typescript-definitions` also skips - by default -  PhantomData fields ... sorry ghost who walks)
* serialize_with="typescript_definitions::as_byte_string"
* transparent: Newtypes are automatically transparent. Structs with a single field can
  be marked transparent.

`serialize_with`, if placed on a `[u8]` or `Vec<u8>` field, will take
that field to be a string. (And serde_json will output a `\xdd` encoded
string of the array. *or* you can create your own... just ensure to name it `as_byte_string`)

```rust
use serde::Serialize;
use typescript_definitions::{TypeScriptify, TypeScriptifyTrait};

#[derive(Serialize, TypeScriptify)]
struct S {
     #[serde(serialize_with="typescript_definitions::as_byte_string")]
     image : Vec<u8>,
     buffer: &'static [u8],
}

println!("{}", S::type_script_ify());
```

 prints `export type S = { image: string, buffer: number[] };`.

Serde attributes understood but *rejected*:

* flatten (This will produce a panic). Probably will never be fixed.

All others are just ignored.


## typescript-definition attributes

Some types, for example `chrono::DateTime`, will serializes themselves in an opaque
manner. Youn need to tell `typescript-definitions`, viz:

```rust
use chrono::prelude::*; 
use serde::Serialize;
use typescript_definitions::{TypeScriptify, TypeScriptifyTrait};

#[derive(Serialize, TypeScriptify)]
pub struct Chrono {
    #[ts(ts_type="string")]
    pub datetime: DateTime<Local>,
}
```

Any typescript type can be used *unless* you are want a type guard generated, then
only string, number and boolean are accepted at the moment.

## Type Guards

`typescript-definitions` type guards provide a fail fast defensive check that
a random json object agrees with the layout and types of a given `typescript-definitions`
type.

To enable them change your dependency to:

```toml
typescript-definitions = { version="0.1.9", features=["type-guards"] }
```

With the feature *on* you can turn guard generation *off* for any struct/enum with the
`#[ts(guard=false)]` attribute.

If your struct has a long list of data as `Vec<data>` then you can prevent a
type check of the entire array with a field attribute `#[ts(array_check="first")]`
which will check only the first row.

### Limitations of JSON

e.g. Maps with non string keys: This

```rust
use wasm_bindgen::prelude::*;
use serde::Serialize;
use std::collections::HashMap;
use typescript_definitions::TypescriptDefinition;
#[derive(Serialize, TypescriptDefinition)]
pub struct IntMap {
    pub intmap: HashMap<i32, i32>,
}
```

will generate:

```typescript

export type IntMap = { intmap: { [key: number]: number } };
```

But the typescript compiler will type check this:

```typescript
let v : IntMap = { intmap: {  "6": 6, 4: 4 } };
```

So the generated guard also checks for integer keys with `(+key !== NaN)`.

### Limitations of Generics

`typescript-definitions` has limited support for verifing generics.

Rust and typescript diverge a lot on what genericity means. Generic Rust structs
don't map well to generic typescript types. However we don't give up totally.

This will work:

```rust
use wasm_bindgen::prelude::*;
use serde::Serialize;
use typescript_definitions::TypescriptDefinition;

#[derive(Serialize, TypescriptDefinition)]
pub struct Value<T> {
    pub value: T,
}

#[derive(Serialize, TypescriptDefinition)]
pub struct DependsOnValue {
    pub value: Vec<Value<i32>>,
}
```
Since the monomorphization of `Value` in `DependsOnValue` is one of
`number`, `string` or `boolean`. 

Beyond this you will have to write your own guards:

e.g. First markup the generics:

```rust
use wasm_bindgen::prelude::*;
use serde::Serialize;
use typescript_definitions::TypescriptDefinition;

#[derive(Serialize, TypescriptDefinition)]
pub struct Value<T> {
    #[ts(user_type_guard=true)]
    pub value: T,
}

#[derive(Serialize, TypescriptDefinition)]
pub struct DependsOnValue {
    #[ts(user_type_guard=true)]
    pub value: Value<Vec<i32>>,
}
```
Then you will have to write...

```typescript
const isT = <T>(o: any, typename: string): o is T => {
    // Vec<i32> maps to number[]
    if (typename !== "number[]") return false;
    if (!Array.isArray(o)) return false;
    for (let v of o) {
        if (typeof v !== "number") return false;
    }
    return true
}
```

Watch out for function name collisons especially if you use simple names
such as `T`, for a generic
type name.

The generated output file should really be passed through something like [prettier](https://www.npmjs.com/package/prettier).

## Examples

Top level doc (`///` or `//!` ) comments are converted to javascript (line) comments:

```rust
use serde::Serialize;
use typescript_definitions::{TypeScriptify, TypeScriptifyTrait};
#[derive(Serialize, TypeScriptify)]
/// This is some API Event.
struct Event {
    what : String,
    pos : Vec<(i32,i32)>
}

assert_eq!(Event::type_script_ify(), "\
// This is some API Event.
export type Event = { what: string; pos: [ number , number ][] };"
)
```

## Problems

Oh yes there are problems...

Currently `typescript-descriptions` will not fail (AFAIK) even for
structs and enums with function pointers `fn(a:A, b: B) -> C` (generates typescript lambda `(a:A, b:B) => C`)
and closures `Fn(A,B) -> C` (generates `(A,B) => C`). These make no sense in the current
context (data types, json serialization) so this might be considered a bug.
Watchout!

This might change if use cases show that an error would be better.

If you reference another type in a struct e.g.

```rust
// #[cfg(target_arch="wasm32")]
use wasm_bindgen::prelude::*;
use serde::Serialize;
use typescript_definitions::{TypescriptDefinition};
#[derive(Serialize)]
struct B<T> {q: T}

#[derive(Serialize, TypescriptDefinition)]
struct A {
    x : f64,
    b: B<f64>,
}
```

then this will "work" (producing `export type A = { x: number ,b: B<number> })`) but B will be opaque to
typescript unless B is *also* `#[derive(TypescriptDefinition)]`.

Currently there is no check for this omission.

Also Trait bounds are stripped out for typescript; you can't serialize Traits! However...

If using `type_script_ify` then anything other than simple trait bounds will fail to compile. (because
the `impl<...> TypeScriptify for T<...> {}` that is automatically generated by `typescript-descriptions` will be garbled).

* no `where` clauses.
* no generic Traits.

Use `WASM` instead.

This might be relaxed in future.

----

The following types are rendered as:

* `Option<T>` => `T | null` (can't use undefined because this will mess with object checking)
* `HashMap<K,V>` => `{ [key:K]:V }` (same for `BTreeMap`)
* `HashSet<V>` => `V[]` (same for `BTreeSet`)
* `&[u8]` and `Vec<u8>` are expected to be byte buffers but are still rendered as `number[]` since
  this is what `serde_json` does. However you can force the output to be a string using
  `#[serde(serialize_with="typescript_defintions::as_byte_string")]`

An `enum` that is all Unit types such as

```rust
enum Color {
    Red,
    Green,
    Blue
}
```
is rendered as a typescript enum:

```typescript
enum Color {
    Red = "Red",
    Green ="Green",
    Blue = "Blue"
}
```

because serde_json will render `Color::Red` as the string `"Red"` instead of `Color.Red`
(because JSON).

TODO: What about `enum Color {Red = 0, Green = 1 , Blue= 2}`?

Serde always seems to render `Result` (in json) as `{"Ok": T } | {"Err": E}` i.e as "External"
so we do too.


Formatting is rubbish and won't pass tslint. This is due to the quote! crate taking control of the output
token stream. I don't know what it does with whitespace for example... (is whitespace a token in rust?).
Anyhow... this crate applies a few bandaid regex patches to pretty things up.


We are not as clever as serde or the compiler in determining the actual type. For example this won't "work":

```rust
use std::borrow::Cow as Pig;
use typescript_definitions::{TypeScriptify,TypeScriptifyTrait};

#[derive(TypeScriptify)]
struct S<'a> {
    pig: Pig<'a, str>,
}
println!("{}", S::type_script_ify());
```

gives `export type S = { pig : Pig<string> }` instead of `export type S = { pig : string }`
Use `#[ts(ts_type="string")]` to fix this.

At a certain point `typescript-definitions` just *assumes* that the token identifier `i32` (say)
*is* really the rust signed 32 bit integer and not some crazy renamed struct in your code!

Complex paths are ignored `std::borrow::Cow` and `mycrate::mod::Cow` are the same to us. We're
not going to reimplement the compiler to find out if they are *actually* different. A Cow is
always "Clone on write".

We can't reasonably obey serde attributes like "flatten" since we would need
to find the *actual* Struct object (from somewhere) and query its fields.

## TODO

Generate a typescript verifier for each type (maybe). We really need some
testing of the typescript types against serde_json.

```typescript
export verify_A<T>(obj: any): boolean {/*... */ }
// *or*
export verify_A<T>(obj: any): {Ok: A<T>} | {Err: string} {/* ... */}
// *or* using guards https://www.typescriptlang.org/docs/handbook/advanced-types.html
export is_A<T>(obj: any): obj is A<T> { /* ... */ }
```
or something...

Then one could:

```typescript
let o : any = JSON.parse(some_string_from_the_inet);
if verify_A<number>(o) {
    return o as A<number>
} else {
    // err....
}
```

maybe...

## Credits

For intial inspiration see http://timryan.org/2019/01/22/exporting-serde-types-to-typescript.html

Forked from [`wasm-typescript-definition` by @tcr](https://github.com/tcr/wasm-typescript-definition?files=1)
which was forked from [`rust-serde-schema` by @srijs](https://github.com/srijs/rust-serde-schema?files=1).

`type_script_ify` idea from [`typescriptify` by @n3phtys](https://github.com/n3phtys/typescriptify)

Probably some others...

## License

MIT or Apache-2.0, at your option.
*/
